{"data":{"site":{"siteMetadata":{"title":"Another Chris","author":"Chris Small"}},"markdownRemark":{"id":"59390fb5-00dc-5bc8-9457-759ae81b2935","excerpt":"Part 1 Part 2 Part 3 Flushing your Streams Flush is available in all Stream and Writer classes. Quite often it’s essential that you Flush() before you read back…","html":"<ul>\n<li><a href=\"/net/inside-the-systemio-namespace-part-1\">Part 1</a></li>\n<li><a href=\"/net/inside-the-systemio-namespace-part-2\">Part 2</a></li>\n<li>Part 3</li>\n</ul>\n<h3>Flushing your Streams</h3>\n<p>Flush is available in all Stream and Writer classes. Quite often it’s essential that you Flush() before you read back, otherwise the data you have previously written to the stream doesn’t get written to the Stream’s buffer. A good example of this is the NetworkStream example further down. </p>\n<!--more-->\n<p>On the following Stream or Writer classes, Flush performs the following actions:</p>\n<ul>\n<li>StreamWriter - Calls write if necessary on the stream, and then flush on the stream.</li>\n<li>TextWriter - Does nothing</li>\n<li>StringWriter - Does nothing</li>\n<li>BinaryWriter - Calls flush on the stream</li>\n<li>Stream - Abstract method</li>\n<li>BufferedStream - Calls write or read, depending on the current write position. Write actually calls Write and then Flush on the underlying stream, while reed seeks to the end of the stream.</li>\n<li>NetworkStream - Does nothing</li>\n<li>FileStream - Does a lot!</li>\n<li>MemoryStream - Does nothing</li>\n</ul>\n<h3>Manipulating Streams - the Reader/Writer helper classes</h3>\n<p>On first glance there seem to be a lot of different ways of doing the same thing with reading and writing inside the IO namespace in .NET. Writing and reading from a Stream object can be done with any of the classes in the image below.</p>\n<p><img src=\"/assets/2010/10/readerwriter.gif\" alt=\"Reader Writer\"></p>\n<p>The class hierarchy can infact be simplified into just 2 types of classes: BinaryReader/Writer and TextReader/Writer and their derived classes.</p>\n<h3>BinaryReader/BinaryWriter</h3>\n<p>The BinaryReader/Writer classes are intended for writing simple types to files. The classes support bool,float,integerss,strings and more along the same kind of lines as the Java DataInputStream and DataOutputStream classes. They support different encoding types. You might be mistaken for thinking they are intended for writing and reading data in as bytes, however this is generally the jobs of the StreamReader/Writer classes (or just raw manipulation of the Stream itself).</p>\n<h3>BinaryWriter</h3>\n<p>BinaryWriter has 4 methods:Close,Flush,Seek,Write and a BaseStream property for the stream it’s writing to. It implements IDisposable so can be wrapped inside a using() clause just like the Stream classes could, which it most usually will be.</p>\n<h4>Strings</h4>\n<p>The BinaryWriter writes a string using the encoding you specify in the constructor, or the default encoding (Windows 1252 for most Western users as mentioned above). How does it know where to read to? It prepends the string length and then the string itself. For example:</p>\n<pre>writer.Write( \"Hello world\" );\n</pre>\n<p>This comes out as</p>\n<pre>0b 48 65 6c 6c 6f 20 77 6f 72 6c 64\n</pre>\n<p>So 0b (11) is the length of “Hello world” followed by the string. If you have written a different format such an integer and then read it back in, it will just try to read this back using the symbol table for the encoding you have. For example:</p>\n<pre>writer.Write( \"Hello world\" );\nwriter.Write( (byte) 11 );\nwriter.Write( \"Hello world\" );\n</pre>\n<p>will come back as two strings: “Hello world” and “vHello worl”. Changing the line (byte) 11 to (byte) 255 gets you an EndOfStreamException.</p>\n<h4>Ints</h4>\n<pre>//\n// Ints\n//\n// Uses 4 bytes to write each int\nwriter.Write(1); // 01\nwriter.Write(10); // 0a\nwriter.Write(100); // 64\nwriter.Write(1000); // 3e8\nwriter.Write(10000); // 2710\n//writer.Write(123456789); // 75BCD15\n</pre>\n<p>The above is displayed as:</p>\n<pre>01 00 00 00 0a 00 00 00 64 00 00 00 e8 03 00 00 10 27 00 00 15 cd 5b 07\n</pre>\n<p>The output is Little Endian Format, which puts the Least Significant Bit (LSB) first, or in other words the digits are read right to left. As you can see ints are 0 zero padded and assumed to be 32bit integers rather than scaling it up and down according to the number (e.g. only using 1 byte for the 1, 10, 100, 1000, 10000).</p>\n<p>If you want to write integers/floats out using Big Endian, Jon Skeet has written a utility for doing so <a href=\"http://www.yoda.arachsys.com/csharp/miscutil/\">here</a>.</p>\n<h4>Bools</h4>\n<pre>// Boolean\nwriter.Write(true);\nwriter.Write(false);\n</pre>\n<p>Bools are written as 1 byte integers of value 1 or 0. This appears to waste space, but makes sense as the Reader would be unable to tell whether something like 10000000 (8 bits) was<br>\ntrue,false,false,false,false,false,false,false, i.e. 8 bool values, or just 1 true value and 7 empty values.</p>\n<h4>Small ints</h4>\n<pre>// Small int\nwriter.Write((Int16) 100);\nSmall int only uses 2 bytes, so the above is written as (padded zeros)0x6400\n</pre>\n<h4>Floats</h4>\n<p>Looking at the source code of BinaryWriter, floats (single) are written the following way using unsafe code:</p>\n<pre>uint num = *((uint*) &value);\nthis._buffer[0] = (byte) num;\nthis._buffer[1] = (byte) (num &gt;&gt; 8);\nthis._buffer[2] = (byte) (num &gt;&gt; 0x10);\nthis._buffer[3] = (byte) (num &gt;&gt; 0x18);\nthis.OutStream.Write(this._buffer, 0, 4);\n</pre>\n<p>This is takes value (a float) and dereferences it, getting the memory address’s contents which is a hexadecimal.</p>\n<p>So for 0.01f you get 0x3c23d70a.</p>\n<p>The lines that follow split this value into its 4 byte parts, the first is the last byte (0a - conversion to a byte drops the other 3 bytes). It then extracts d7 by bit shifting to the right by 8 bits, and then again by 16 bits, and finally 24 bits.</p>\n<p>Writing a double uses a similar technique too. If you’re curious how 0.01 came to be represented as 0x3c23d70a, take a look at this tool to see how IEEE-754 floating point numbers (single/double value types) are stored in memory in the CLR. 1 bit is used for the sign, 8 bits for the exponent, and the remaining 23 bits (for single precion/float) for the mantissa or significand.</p>\n<h3>BinaryReader</h3>\n<p>This is a straight forward case of reading back the values you’ve written. If you try to replace int32 values with int16 it reads them back as 0. The same applies for bool values, which takes the byte and converts from there. It is a forward only reader. You can optionally just read the entire byte stream back as shown in the comments below, and then process as you want, but this is suited for a stream that you didn’t write or know the format of.</p>\n<pre>using (FileStream stream = new FileStream(@\"c:binarywriter.dat\", FileMode.Open))\n{\n\tBinaryReader reader = new BinaryReader(stream);\n\n\t//byte[] b = reader.ReadBytes( (int) stream.Length );\n\tint i = reader.ReadInt32();\n\ti = reader.ReadInt32();\n\ti = reader.ReadInt32();\n\ti = reader.ReadInt32();\n\ti = reader.ReadInt32();\n\ti = reader.ReadInt32();\n\treader.Close();\n}\n</pre>\n<h3>TextReader/TextWriter</h3>\n<p>The abstract TextReader and TextWriter are the basis for the StreamReader/Writer and StringReader/Writer classes. These 4 classes are geared towards reading/writing text, as the base classes imply.</p>\n<p>TextReader supplies the following methods</p>\n<ul>\n<li>Close</li>\n<li>Peek</li>\n<li>Read</li>\n<li>ReadBlock</li>\n<li>ReadLine</li>\n<li>ReadToEnd</li>\n</ul>\n<p>TextWriter provides:</p>\n<ul>\n<li>Close</li>\n<li>Flush</li>\n<li>Write</li>\n<li>WriteLine</li>\n</ul>\n<p>Anyone that has written custom server controls will be familiar with the TextWriter as the HttpTextWriter is derived from it.</p>\n<h3>StringWriter</h3>\n<p>StringWriter uses a StringBuilder to write strings in a very similar way to StringBuilder, but obviously without being able to read back (it actually uses a StringBuilder behind the scenes). A common use is with the XmlTextReader in the System.XML namespace, which takes a StringWriter in one of its constructors. This is the easiest way of writing XML in memory without worrying about using MemoryStreams.</p>\n<p>Under the hood the StringWriter really doesn’t do anything more complex than stringBuilder.Append() using the StringBuilder you provide. From TextWriter, it provides a large set of Write() overloads that take various .NET value types, converting them to their string equivalent.</p>\n<pre>StringBuilder builder = new StringBuilder();\nusing (StringWriter writer = new StringWriter(builder))\n{\n\twriter.Write(true);\n\twriter.Write(12345);\n\twriter.Write((byte) 0x0a);\n\twriter.WriteLine(\"A line of text\");\n}\n\nConsole.WriteLine(builder.ToString());\n</pre>\n<h3>StringReader</h3>\n<p>StringReader takes a string for its constructor and then allows you to read from the string using the methods the TextReader base class hands to it. It doesn’t add any new methods from the base class. Behind the scenes, the to ReadToEnd() simply returns the string, or does a substring if you are advanced pass position zero. It tracks the position you’re at in the character array for this. For to ReadLine() it checks (hardcodes infact) for r and then n and returns the previous line it captured.</p>\n<pre>// The \\r\\n should be replaced Environment.NewLine, although \\r and \\n is hardcoded\n// into the StringReader source.\nstring s = \"A line of text\\r\\nAnother line\";\nusing (StringReader reader = new StringReader(s))\n{\n\tchar next = (char)reader.Peek(); // 65 or A\n\treader.Read();\n\tchar[] line = new char[5];\n\t\t\t\n\t// Set the line variable to contain ' line'.\n\t// N.B. the index argument is based on the current pointer position not the\n\t// string as a whole.\n\treader.ReadBlock(line, 0, 5);\n\tConsole.WriteLine(line);\n\tConsole.WriteLine(reader.ReadLine());\n\t\t\n\t// ReadLine() has advanced the internal pointer to 'A' from 'Another'.\n\treader.Read();\n\treader.Read();\n\treader.Read();\n\tConsole.WriteLine(reader.ReadToEnd());\n}\n</pre>\n<p>The output from the above is:</p>\n<pre>line\n of text\nther line\n</pre>\n<h3>StreamReader</h3>\n<p>StreamReader as the name implies, reads streams. However its purpose is to read text-based streams rather than binary ones, which is why it’s derived from TextReader. It doesn’t add any new methods from TextReader, although it does give you 3 new properties: BaseStream,CurrentEncoding,EndOfStream. It defaults to UT8 if no encoding is set.</p>\n<p>The ReadToEnd() method uses a StringBuilder internally to read through the backing string. ReadLine() is just like the StringReader class’s implementation, but using a StringBuilder rather than a string to build up the string.</p>\n<pre>Stream stream = File.Open(@\"c:INSTALL.LOG\", FileMode.Open);\nusing (StreamReader reader = new StreamReader(stream))\n{\n\t// Read character by character\n\tStringBuilder builder = new StringBuilder();\n\twhile (!reader.EndOfStream)\n\t{\n\t\tbuilder.Append((char)reader.Read());\n\t}\n\tConsole.WriteLine(builder.ToString());\n}\n\n// 0x0A86 is '?' in Unicode (Gujarati AA).\n// Casting it to 2 bytes makes it useable as Unicode.\n// This could be removed if we wanted and stick to UTF32\nbyte[] buffer = BitConverter.GetBytes((Int16)0x0A86);\nMemoryStream stream2 = new MemoryStream(buffer);\nusing (StreamReader reader = new StreamReader(stream2, Encoding.Unicode))\n{\n\tstring contents = reader.ReadToEnd();\n}\n\n// For NetworkStream, see the other example\n// BufferedStream offers no performance benefit so isn't shown\n</pre>\n<p>Below is the example which featured in the NetworkStream section, this time using a StreamReader (and Writer) and also a different URL that returns more (HTML) textual data.</p>\n<pre>string host = \"codeproject.com\";\nstring page = \"/KB/scripting/HTMLFixedHeaders.aspx\";\nTcpClient tcp = new TcpClient();\ntcp.Connect( host, 80 );\nNetworkStream stream = tcp.GetStream();\n\n// Send a HTTP request\nbyte[] data = Encoding.Unicode.GetBytes( string.Format( \"GET {0} HTTP/1.0{1}{1}\", page, \"rn\" ) );\n\n// Make sure you flush or it isn't written out\nStreamWriter writer = new StreamWriter( stream );\nstream.Write(data, 0, data.Length );\nwriter.Flush();\nstring s = \"\";\nusing (StreamReader reader = new StreamReader(stream) )\n{\n\ts = reader.ReadToEnd();\n}\nusing (writer = new StreamWriter( @\"c:out.html\" ) )\n\twriter.Write(s);\n</pre>\n<h2>StreamWriter</h2>\n<p>The StreamWriter does the text equivalent of the BinaryWriter, writing various datatypes to the stream you give it, but as plaintext rather than a byte representation like the BinaryWriter does. The example below illustrates how it’s used to write both plain text, and how it translates to a byte array with MemoryStream.</p>\n<pre>public static void StreamWriterTest()\n{\n\t// Basic test\n\tusing ( StreamWriter writer = new StreamWriter(@\"c:streamwriter.dat\") )\n\t{\n\t\twriter.Write(true);\n\t\twriter.Write(1234);\n\t\twriter.Write(\"A string\");\n\t\twriter.WriteLine(\"A whole line of text!\");\n\t\twriter.WriteLine(1234);\n\t}\n\t\n\t// Output:\n\t//\n\t// True1234A stringA whole line of text!\n\t// 1234\n\t//\n\t//\n\t// Test with MemoryStream\n\tMemoryStream memoryStream = new MemoryStream( 8 );\n\tusing ( StreamWriter writer = new StreamWriter(memoryStream) )\n\t{\n\t\twriter.Write( \"1234\" );\n\t}\n\n\t// This only returns the amount of bytes in the MemoryStream (4 bytes), not the capacity (8 bytes)\n\tbyte[] buffer = memoryStream.ToArray();\n\n\t//\n\t// Output of buffer with default encoding:\n\t// 49,50,51,52\n\t// e.g. The ascii equivalent of those numbers.\n\t//\n\t// With unicode it's a 10 byte array, first two are 254,255 (not sure what this is),\n\t// followed by 49,0,50,0,51,0,52,0\n}\n</pre>\n<h2>Closing writers and streams</h2>\n<p>All of the classes mentioned in this article (except File of course) implement IDisposable. This allows you to wrap them in the using() clause which ensures they are efficiently disposed and collected by the GC.</p>\n<p>In dealing with the streams and the helper classes this way, you don’t need to worry about calling Close, as the Dipose() methods do this for you, either directly on the stream or on the underlying stream in the case of the reader/writer helpers.</p>\n<h2>System.IO and System.XML</h2>\n<p>The commonest use inside the framework class library for the stream read/writers is inside the System.XML namespace. The XmlTextReader and XmlReader classes both take a TextReader (the latter in its constructor, former in the static Create method).</p>\n<h2>IO Exception handling</h2>\n<p>The IO exception hierachy (below) is fairly straight forward, with specialized classes for catching specific errors like the common error of not finding the file.</p>\n<p><img src=\"/assets/2010/10/ioexception.gif\" alt=\"IO Exceptions\"></p>\n<p>With several of the IO classes like FileStream you will need to nest catching to gracefully close the stream, for example </p>\n<pre>try\n{\n\t// Open a file\n\ttry\n\t{\n\t\t// read the stream\n\t}\n\tcatch (EndOfStreamException e)\n\t{\n\t\t// close the stream here\n\t}\n}\ncatch (FileNotFoundException e)\n{\n}\n</pre>\n<p>Of course you could catch the whole lot in an IOException, but this is widely accept as a bad practice in exception handling; you should only catch what you are expecting to fail, leave the rest to the caller, or a more generic exception handler such as Application.ThreadException in windows forms app.</p>\n<p>Other exceptions you need to watch out for when performing IO operations, that don’t inherit from IOException:</p>\n<h3>System.UnauthorizedAccessException.</h3>\n<p>One scenario this can happen is if you try to open a file that is readonly, and want to write to it. File.Open does this when you don’t set the FileAccess.Read as a parameter, as it sets the FileStream to FileAccess.ReadWrite. </p>\n<blockquote>\n<p>{“The process cannot access the file ‘C:xxx’ because it is being used by another process.”} </p>\n</blockquote>\n<p>These errors occur when something else is opening and using your file. They throw an IOException rather than an UnauthorizedAccessException. </p>\n<h3>System.NotSupportedException.</h3>\n<p>This can occur if you try to Write() to a stream that has been opened with read access only.</p>\n<h3>System.ArgumentException.</h3>\n<p>This is thrown if you try to read from a stream at a point that doesn’t exist in it, the “offset and length were out of bounds” error.</p>\n<h3>System.OutOfMemoryException.</h3>\n<p>Reading very large files (eg dvd-size) or buggy in-memory manipulation with MemoryStreams can be culprits for this. Test it for yourself using:</p>\n<pre>byte[] b = new byte[int.MaxValue];</pre>","frontmatter":{"title":"Inside The System.IO Namespace Part 3","date":"October 26, 2010","description":"The final part to a series of posts looking at the System.IO namespace."}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/2010-10-26-inside-the-system-io-namespace-part-3/","previous":{"fields":{"slug":"/2010-10-19-inside-the-system-io-namespace-part-2/"},"frontmatter":{"title":"Inside The System.IO Namespace Part 2"}},"next":{"fields":{"slug":"/2010-11-03-a-new-web-front-end-for-team-foundation-server/"},"frontmatter":{"title":"A new web front end for Team Foundation Server"}}}}
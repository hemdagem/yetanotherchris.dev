{"data":{"site":{"siteMetadata":{"title":"Another Chris","author":"Chris Small"}},"markdownRemark":{"id":"9776e7ab-5d10-5ddb-8daa-5ddfa2006fb2","excerpt":"After a few months off to eat a lot of food, I’m returning to do more dev work on Spruce. Picking up where I left off, the first  “ subsystem ”  I’m focusing on…","html":"<p>After a few months off to eat a lot of food, I’m returning to do more dev work on Spruce.</p>\n<p>Picking up where I left off, the first “subsystem” I’m focusing on is the search. The UI and search I have in mind is fairly simple, but also powerful. I’m aiming to keep it google-esque in its search results and allow you to search the important fields of a work item, plus its core fields.</p>\n<p>The header for the front end has a search box in the top right, which will support all of the search syntax. This then leads onto a search page which will give a few more tips. The search syntax I have in mind is:</p>\n<!--more-->\n<blockquote>\n<p>start:”last month” end:”yesterday” project:amazing-project </p>\n</blockquote>\n<p>These are google style field searches (much like site:yahoo.com in a google search). Any free text not given in this format is assumed to search the title, and possibly the body too although I’m not sure what performance issues this will have so it may become a field search.</p>\n<p>The quick and dirty solution to parse the search syntax for this would be a collection of regexs. However I’m keen to use a more form CS approach where I’m given a parse tree as I mentioned in the last post. I’m in the middle of specifying the grammar in BNF which will be translated to C# syntax using the Irony framework.</p>\n<p>Having tinkled with Irony for a few hours I’m really impressed with its power, and don’t seem to be alone in that respect as it’s got 2,000 downloads of the latest alpha build. It’s quite short on documentation which the author is aware of, but does have a lot of example projects bundled with it.</p>\n<p>What’s more it comes with a Google query to SQL syntax grammar with already made, along with a host of others like Wiki syntax and Python. From my experiments it’s really simple to get going, you declare a grammar and then give it some text to parse. The code below is some rough and ready example code that I wrote to try parsing Markdown syntax, inspired by the fact nobody has written one yet, and the Markdown syntax (a simplified Wiki format) is used for the biggest programmer site out there, Stackoverflow and a plugin I wrote a while back for N2CMS. The only parsers out there are regex based as far as I know.</p>\n<p>The example below only caters for italic and bold but others (except perhaps images and links) would be trivial to add.</p>\n<pre>[Language(\"Markdown\",\"1.0\",\"Grammar for the markdown syntax\")]\npublic class MarkdownGrammar : Grammar\n{\n\tpublic MarkdownGrammar()\n\t{\n\t\t//  ::= ...\n\t\tvar text = new WikiTextTerminal(\"text\") { EscapeChar = '~' };\n\t\tvar lineBreak = new WikiTagTerminal(\"lineBreak\", WikiTermType.Element, @\"\\\\\", string.Empty) { OpenHtmlTag = \"\n\t\t\\n\" };\n\t\t\n\t\t//   ::= \"*\"   \"*\"\n\t\tvar italic = new WikiTagTerminal(\"italic\", WikiTermType.Format, \"*\", \"em\");\n\t\t\n\t\t//   ::= \"*\" \"*\"  \"*\" \"*\"\n\t\tvar bold = new WikiTagTerminal(\"bold\", WikiTermType.Format, \"**\", \"strong\");\n\t\tvar wikiElement = new NonTerminal(\"wikiElement\");\n\t\tvar wikiText = new NonTerminal(\"wikiText\");\n\t\twikiElement.Rule = text | lineBreak | italic | bold | NewLine;\n\t\twikiText.Rule = MakeStarRule(wikiText, wikiElement);\n\t\tthis.Root = wikiText;\n\t\tthis.WhitespaceChars = string.Empty;\n\t\tMarkTransient(wikiElement);\n\t\t\n\t\t//We need to clear punctuation flag on NewLine, so it is not removed from parse tree\n\t\tNewLine.SetFlag(TermFlags.IsPunctuation, false);\n\t\tthis.LanguageFlags |= LanguageFlags.CreateAst;\n\t}\n}\n</pre>\n<p>This example piggy backs on the prebuilt wiki Terminals from the Wiki grammar. Using it is straightforward as shown below. The state machine to tell what tag you’re inside is a nice simple mechanism borrowed from the Irony examples – a dictionary with a value of true/false for each Token:</p>\n<pre>private static Dictionary _flags = new Dictionary();\nstatic void Main(string[] args)\n{\n\tMarkdownGrammar grammar = new MarkdownGrammar();\n\tScriptInterpreter interpreter = new ScriptInterpreter(grammar);\n\tParser parser = new Parser(grammar);\n\tParseTree tree = interpreter.Parser.Parse(\"hello this is *ch**r**is*\");\n\tStringBuilder builder = new StringBuilder();\n\n\tforeach (Token token in tree.Tokens)\n\t{\n\t\tvar t = token.Terminal as WikiTerminalBase;\n\t\tif (t != null)\n\t\t{\n\t\t\tif (t.TermType == WikiTermType.Format)\n\t\t\t{\n\t\t\t\tbuilder.Append(ProcessFormatTag(token));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tbuilder.Append(token.ValueString);\n\t\t\t}\n\t\t}\n\t}\n\n\tConsole.Read();\n}\n\nprivate static string ProcessFormatTag(Token token)\n{\n\tvar term = token.Terminal as WikiTerminalBase;\n\tbool value;\n\tbool isOn = _flags.TryGetValue(term, out value) && value;\n\t_flags[term] = !isOn;\n\n\tif (isOn)\n\t\treturn term.CloseHtmlTag;\n\telse\n\t\treturn term.OpenHtmlTag;\n}\n</pre>\n<p>Obviously this is for markdown syntax and not the search grammar however I thought I’d blog a small example of how easy Irony is to use a parsing engine. It does require reading up on BNF (Backus-Naur Form) on wikipedia (read the <a href=\"http://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_Form\">EBNF</a> page first as it is a good intro) but as an alternative to regexes for formal DSLs it’s rather good.</p>\n<p>The next Spruce post will feature some of the BNF definition I have in mind for the searching.</p>\n<p><strong>Irony-related links</strong></p>\n<ul>\n<li><a href=\"http://irony.codeplex.com/\">Irony on codeplex</a></li>\n<li><a href=\"http://en.wikibooks.org/wiki/Irony_-_Language_Implementation_Kit\">Wikibooks documentation for Irony</a> – also check out the 3 codeproject articles athough they’re slightly out of sync with the api now.</li>\n</ul>","frontmatter":{"title":"Starting on Spruce's irony-powered search parser","date":"February 14, 2011","description":"After a few months off to eat a lot of food, I’m returning to do more dev work on Spruce. Picking up where I left off, the first “subsystem” I’m focusing on is the search. The UI and search I have in mind is fairly simple, but also powerful. I’m aiming to keep it google-esque in its search results and allow you to search the important fields of a work item, plus its core fields."}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/2011-02-14-starting-on-spruces-irony-powered-search-parser/","previous":{"fields":{"slug":"/2011-02-02-csharp-bit-manipulation-by-example-part-2/"},"frontmatter":{"title":"C# Bit manipulation by example (part 2)"}},"next":{"fields":{"slug":"/2011-02-21-spruce-from-irony-net-to-goldparser/"},"frontmatter":{"title":"Spruce: From Irony.NET to GoldParser"}}}}
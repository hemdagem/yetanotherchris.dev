{"data":{"site":{"siteMetadata":{"title":"Another Chris","author":"Chris Small"}},"markdownRemark":{"id":"af705a1e-1fea-5a0e-becb-ed9c3f29ea44","excerpt":"No boxing topic is complete without a quick summary of value types and reference types: Value types Stored on the stack (STAtiC types are stored in the STACk…","html":"<p>No boxing topic is complete without a quick summary of value types and reference types:</p>\n<h2>Value types</h2>\n<ul>\n<li>\n<p>Stored on the stack (STAtiC types are stored in the STACk), unless it is inside a reference type (e.g. a property on a class) where it is then accessed by reference or pointer.</p>\n</li>\n<li>\n<p>Passed around by value rather than a memory location (pointer). This means that when you call a method that takes value types as its parameter, the values are copied.</p>\n</li>\n<li>\n<p>Not garbage collected.</p>\n<!--more-->\n</li>\n<li>\n<p>Doesn’t support inheritence, only implementations of Interfaces (the built in Enum type does infact inherit from ValueType but that’s built into the framework</p>\n</li>\n<li>\n<p>The default base Equals() method (inside ValueType) is slow as it uses reflection to get every field’s value and do a comparison with each of these versus the object.</p>\n</li>\n<li>\n<p>Have to be initialised, they can’t be null (enforced by the compiler however ILasm is forgiving and generates a 1 byte value if they’re null).</p>\n</li>\n<li>\n<p>Since .NET 2.0 value types can be nullable by prefixing ? before the type, e.g. int? myvalue; This indicates that zero might be a valid value, so null implies no value has been set.</p>\n</li>\n<li>\n<p>The ? shortcut translates into:</p>\n</li>\n</ul>\n<h4>Example</h4>\n<pre>Nullable n = new Nullable();\nn = null;\n</pre>\n<h2>Reference types</h2>\n<ul>\n<li>Stored on the heap.</li>\n<li>Passed as pointers rather than the actual value;</li>\n<li>Supports inheritence</li>\n<li>The default base Equals() method (inside Object) compares both object’s memory location rather than field values, so this is fast.</li>\n<li>Can be null</li>\n<li>Are garbage collected depending on how new they are and if anything has a reference to the instance.</li>\n</ul>\n<p>In short, boxing is taking a value type, and turning it into a reference type. This is done by the CLR by copying every field’s value into a reference type. Unboxing is taking a boxed reference type and turning it back into a value type.</p>\n<p>Implied boxing means you aren’t forceable trying to box the valuetype, but rather it happens automatically, such as</p>\n<pre>int i = 30;\nobject o = i;\n</pre>\n<p>Explicit boxing is when you are performing the box to a reference type via a manual cast:</p>\n<pre>int i = 30;\nobject o = (object) i;\n</pre>\n<p>Boxing requires a performance hit, particularly inside loops. Unboxing is not so intense as the values are stored inside the boxed reference (the first point under the Vale type section) type and can just be retrieved back. Most examples of boxing out there show an example turning an int into an object and back, such as:</p>\n<pre>int n = 100;\nObject o = n;\nint x = (int) o;\nn = 200;\nConsole.WriteLine(o);\n</pre>\n<p>You would rarely want to achieve something like the above, particularly since the introduction of generics in 2.0. One of the biggest gains generics added to .NET in 2.0 was the ability to add value types to a collection without the need to box. Consider the following: </p>\n<pre>int n = 100;\nArrayList list = new ArrayList();\nlist.Add(n);\nlist.Add(n);\nn = 200;\nConsole.WriteLine(list[0]); // prints 100\nConsole.ReadLine();\n</pre>\n<p>Here n is being boxed twice, once each time time it’s stored inside the ArrayList. The underlying IL is:</p>\n<pre>IL_000c: box [mscorlib]System.Int32\nIL_0011: callvirt instance int32 [mscorlib]System.Collections.ArrayList::Add(object)\n</pre>\n<p>Changinge the above code to a List<T>:</p>\n<pre>int n = 100;\nList&lt;int&gt; list = new List&lt;int&gt;();\nlist.Add(n);\nlist.Add(n);\nn = 200;\n</pre>\n<p>Compiles into:</p>\n<pre>IL_000c: callvirt instance void class [mscorlib]System.Collections.Generic.List`1::Add(!0)\nIL_0011: nop\n</pre>\n<p>The box keyword is now gone. Generic collections remove the boxing of value types when dealing with lists and collections in general adding huge performance gains. Infact there is a whole thread <a href=\"http://www.gamedev.net/community/forums/topic.asp?topic_id=456728&#x26;PageSize=25&#x26;WhichPage=1\">here</a> about the difference in speed between a none generics ArrayList and a List<T>. </p>\n<p>There is also MSDN information about boxing at <a href=\"http://msdn.microsoft.com/en-us/library/25z57t8s.aspx\">MSDN online</a>. </p>\n<h2>The As keyword instead of explicit casting.</h2>\n<p>Consider the following block of C#:</p>\n<pre>public override bool Equals(Object obj)\n{\n\tif ( obj != null)\n\t{\n\t\tMyClass myclass = (MyClass) obj;\n\t\t// do some comparison with myclass\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\n</pre>\n<p>This is a common branching block that is regularly written. The problem with it is it unnecessarily performs two casts. When called repeatedly over a set of thousands of objects this can be a performance hit. It’s avoidable however, thanks to the ‘As’ keyword, illustrated below. No exception is thrown if obj is null when using ‘as’, whilst a bracketed cast would do this. </p>\n<pre>public override bool Equals(object obj)\n{\n\tMyClass myclass = obj as MyClass;\n\tif (myclass != null)\n\t{\n\t\t// do some comparison with myclass\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\n</pre>","frontmatter":{"title":"Value types, reference types, boxing and unboxing in C#","date":"December 14, 2009","description":"There's hundreds of posts and articles out there about value vs reference types, boxing and unboxing, the stack and the heap. Here's another!"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/2009-12-14-value-types-reference-types-boxing-and-unboxing/","previous":{"fields":{"slug":"/2009-11-15-embedded-resources-example/"},"frontmatter":{"title":"Embedded resources example"}},"next":{"fields":{"slug":"/2010-01-01-using-jquery-with-asp-net/"},"frontmatter":{"title":"Using JQuery with ASP.NET"}}}}